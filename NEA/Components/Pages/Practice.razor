@page "/practice"
@rendermode InteractiveServer
<h1>PRACTICE</h1>
<div class="box">
Instructions: tick different boxes to choose what type of cipher you want to practice decrypting. Either choose a specific cipher, the components you want to practice, or randomise it!<br />
For hints (which may be necessary for some problems), click the hint button, which will reveal them one at a time.<br />
To check your answer, type it into the answer box and press submit.
</div>

<div class="box choices">
    <select @bind=choice @bind:event="oninput">
        <option value="specific">Specific cipher</option>
        <option value="parts">Choose the components</option>
        <option value="random">Random!</option>
    </select>
    
    <br />
    @if(choice == "specific")
    {      
        <h6>Individual Ciphers</h6>

        <fieldset>
            <InputRadioGroup @bind-Value="cipher">
                @foreach (string cipher in ciphers)
                {
                    <div>
                        <label>
                            <InputRadio Value="cipher" />
                            @cipher
                        </label>
                    </div>
                }
            </InputRadioGroup>
        </fieldset>

    } 
    else if (choice == "parts")
    {
        <h6>Components</h6>
        <span>Polyalphabetic</span>
        <label class="switch">
            <input type="checkbox" @bind="mono">
            <span class="slider"></span>
        </label>
        <span>Monoalphabetic</span>
        <br />
        <span>Transposition</span>
        <label class="switch">
            <input type="checkbox" @bind="substitution">
            <span class="slider"></span>
        </label>
        <span>Substitution</span>
        
    }
    else if(choice == "random")
    {
        <h6>Random</h6>
        <button>RANDOM</button>
    }
</div>
<button @onclick="Generate">GENERATE CIPHERTEXT</button>
<br />
<p>@ciphertext</p>
<textarea>@decryptionAttempt</textarea>
<button>SUBMIT</button>

<button @onclick="Hint">HINT</button>
<p>@hints</p>
<p>@mono</p>
<p>@substitution</p>

@code {
    Random rnd = new Random();
    int hintCount = 0;

    string choice = "";
    string cipher = "";
    string decryptionAttempt = "";

    bool mono = false, substitution = false;

    string[] ciphers = { "caesar", "affine", "substitution", "vigenere", "railfence"};
    string plaintext = "", ciphertext = "", hints  ="";   


    void getSampleText()
    {
        Random rnd = new Random();
        string[] paragraphs = File.ReadAllLines(System.IO.Path.Combine(System.IO.Directory.GetCurrentDirectory(), "wwwroot/sampleText.txt"));
        plaintext = paragraphs[rnd.Next(1, paragraphs.Length)];
    }

    void Generate()
    {        
        hintCount = 0;
        hints = "";
        Random rnd = new Random();
        getSampleText();   

        switch(choice)
        {
            case "parts":
                if(!mono && !substitution)
                {
                    ciphertext = "Invalid choices";
                    cipher = "";
                }
                else if(!mono)
                {
                    cipher = "vigenere";
                }
                else if(substitution)
                {
                    cipher = ciphers[rnd.Next(0, 3)];
                }
                else
                {
                    cipher = "railfence";
                }

                break;

            case "random":

                cipher = ciphers[rnd.Next(0, ciphers.Length)];

                break;

        }

        if(cipher != "")
        {
            EncryptWithSpecificCipher(cipher);
        }        
    }

    void EncryptWithSpecificCipher(string input)
    {        
        switch (input)
        {
            case "caesar":
                ciphertext = Caesar.Encrypt(plaintext, rnd.Next(1, 25));
                break;

            case "affine":
                ciphertext = Affine.Encrypt(rnd.Next(1, 25), rnd.Next(1, 25), plaintext);
                break;

            case "vigenere":
                string key = "";
                while (key.Length < 26)
                {
                    int c = rnd.Next(0, 26) + 97;
                    if (!key.Contains((char)c))
                    {
                        key += (char)c;
                    }
                }
                ciphertext = Vigenere.Encrypt(key, plaintext);
                break;

            case "substitution":
                string k = "";
                while (k.Length < 26)
                {
                    int c = rnd.Next(0, 26) + 97;
                    if (!k.Contains((char)c))
                    {
                        k += (char)c;
                    }
                }
                //Substitution.getKey()
                //ciphertext = Substitution.Encrypt(key, plaintext);
                break;

            case "railfence":
                ciphertext = Railfence.Encrypt(plaintext, rnd.Next(2, plaintext.Length));
                break;



        }        
    }

    void Hint()
    {
        switch(hintCount)
        {
            case 0:
                hints = "The type of cipher is: " + cipher;
                break;

            case 1:
                hints += "\r\n A part of the plaintext is: " + plaintext.Substring(0, 10);
                break;

        }
        hintCount++;
    }

    void HintBcWrong()
    {
        switch(cipher)
        {
            case "vigenere":
                double iocInput = CryptanalysisFunctions.IndexOfCoincidence(decryptionAttempt);
                double expectedIoc = CryptanalysisFunctions.IndexOfCoincidence(plaintext);
                if(iocInput< expectedIoc)
                {
                    hints += "\n Try a different length of key";
                }
                break;

        }
    }


    bool Check()
    {
        bool error = false;
        int i = 0;
        while(! error && i < ciphertext.Length)
        {
            if(ciphertext[i] != decryptionAttempt[i])
            {
                error = true;
                return false;
            }
        }
        return true;
    }



}
